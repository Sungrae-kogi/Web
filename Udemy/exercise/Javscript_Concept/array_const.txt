*배열을 const로 선언해도 왜 push, pop이 작동할까.*

//const 선언은 블록 범위의 상수를 선언, 상수의 값은 재할당 할 수 없으며 다시 선언할 수도 없다.
//push와 pop 행위가 재할당/재선언이 아니기 때문

ex) const a =[];
    a.push('1'); //메소드 사용

    a = ['1','2']; // 재할당 -> error


*JavaScript 나무위키 참조 *

//객체의 경우 상수로 선언해도 '메모리 값만 상수일 뿐' 객체 안의 내용은 변경이 가능하다.
//즉, 객체가 저장된 공간을 가리키는 정보만 상수일 뿐, 객체의 정보 자체는 변경이 가능.
//따라서, JavaScript에서 객체는 변수로 선언할 이유가 없이 거의 모든 케이스에서 상수로 선언하는게 일반적.
//이렇게 상수로 선언된 객체의 Immutability를 보장하기 위해 여러 테크닉이 쓰이며 주로 ES6에서 도입된
//Spread Operator를 사용하는것이 일반적, 이렇게 객체를 복사하여 사용할 때도 Deep clone하지 않으면
//의도치 않게 원본 객체가 변경되기 때문에 주의가 필요하다.


*Spread Operator란?? *

//스프레드 연산자를 사용하면 배열, 문자열, 객체 등 반복 가능한 객체(Iterable Object)를 개별 요소로 분리 가능하다.
//ex) const arr1 = [1,2,3,4,5];
    const arr2 = [...arr1, 6, 7, 8, 9];     //arr2 = [1,2,3,4,5,6,7,8,9]

//스프레드 연산자는 연결, 복사 등의 용도로 활용도가 높은 편으로 다음 사용 예시들이있다.
//1. 배열 병합
//두 개의 배열 결합에 concat 메소드를 사용했으나 ES6에서는 spread operator를 이용하여 좀 더 깔끔한 병합이 가능
//ex) const arr1 = [1,2,3];
    const arr2 = [4,5,6];
    const arr = [...arr1, ...arr2]; //[1,2,3,4,5,6]

//2. 배열 복사
//JavaScript에서 배열을 새로운 변수에 할당하면 새로운 배열은 기존 배열을 '참조'해버리며 
//이 경우 새로운 배열을 변경하면 기존의 배열까지 변경이 되는 문제가 발생
//배열 복사를 위해서는 기존에는 slice또는 ES5의 map을 이용하여 복사를 했음.
//그러나 Spread Operator를 사용하면 다음과 같이 새로운 복사된 배열 생성이 가능
//ex) const arr1 = ['철수','영희'];
    const arr2 = [...arr1]; //['철수','영희']
    arr2.push('바둑이');    //arr2 = ['철수','영희','바둑이'], arr1 = ['철수','영희'] 기존 배열의 값이 변경되지않음


*함수에서의 Spread Operator *
